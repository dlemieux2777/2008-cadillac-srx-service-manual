/**
 * build-nav-tree.js
 *
 * Reads page-meta.js (generated by build-search-index.js) and outputs:
 *   1. search-data/nav-tree.js   — compact hierarchical tree for sidebar navigation
 *   2. search-data/autocomplete.js — sorted array of page titles for autocomplete
 *
 * The tree is built from breadcrumb paths, which encode the full hierarchy:
 *   "Repair and Diagnosis > Relays and Modules > ... > Alarm Module"
 *
 * Run:  node build-nav-tree.js
 */

const fs = require('fs');
const path = require('path');

const MANUAL_DIR = __dirname;
const SEARCH_DATA_DIR = path.join(MANUAL_DIR, 'search-data');
const META_FILE = path.join(SEARCH_DATA_DIR, 'page-meta.js');

// Escape non-ASCII characters for safe .js files
function asciiSafeJSON(obj) {
  return JSON.stringify(obj).replace(/[\u0080-\uffff]/g, ch =>
    '\\u' + ch.charCodeAt(0).toString(16).padStart(4, '0')
  );
}

// Page type mapping (same as build-search-index.js)
const SECTION_TYPE_MAP = {
  'Testing and Inspection': 'testing',
  'Service and Repair': 'service',
  'Diagrams': 'diagrams',
  'Locations': 'locations',
  'Technical Service Bulletins': 'tsb',
  'Labor Times': 'labor',
  'Specifications': 'specifications',
  'Diagnostic Trouble Codes': 'dtc',
  'Description and Operation': 'description',
  'Service Precautions': 'precautions',
  'Tools and Equipment': 'tools',
  'Adjustments': 'adjustments',
  'Parts': 'parts',
};

function run() {
  console.log('Reading page metadata...');

  // Load page-meta.js by evaluating it
  const metaSource = fs.readFileSync(META_FILE, 'utf-8');
  // page-meta.js sets window._searchData.meta = [...]
  // We need to extract the JSON array
  const window = { _searchData: {} };
  eval(metaSource);
  const pages = window._searchData.meta;

  console.log(`Loaded ${pages.length} pages.`);

  // --- Build tree from breadcrumbs ---
  // Tree structure: { name, id?, pageType?, children: { name: subtree } }
  const tree = { name: 'root', children: {} };

  for (const page of pages) {
    if (!page.breadcrumb) continue;

    const parts = page.breadcrumb.split(' > ').map(s => s.trim()).filter(Boolean);
    let node = tree;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (!node.children[part]) {
        node.children[part] = { name: part, children: {} };
      }
      node = node.children[part];
    }

    // Attach page info to the leaf node
    // If this node already has an id, it's a hub page — the new page is a sibling
    if (!node.id) {
      node.id = page.id;
      node.pageType = page.pageType;
      node.title = page.title;
    } else {
      // This breadcrumb path already has a page — this is a section under it
      // Add as a child with its title
      const title = page.title.split(':').pop().trim() || page.title;
      node.children[title] = node.children[title] || { name: title, children: {} };
      node.children[title].id = page.id;
      node.children[title].pageType = page.pageType;
      node.children[title].title = page.title;
    }
  }

  // --- Convert tree to compact format ---
  // Compact format: [name, id_or_null, pageType_or_null, children_array]
  // children_array is an array of the same format
  function compactify(node) {
    const childKeys = Object.keys(node.children);
    const children = childKeys.map(key => compactify(node.children[key]));
    return [
      node.name,
      node.id || null,
      node.pageType || null,
      children.length > 0 ? children : null
    ];
  }

  // Get top-level sections
  const topLevelKeys = Object.keys(tree.children);
  const compactTree = topLevelKeys.map(key => compactify(tree.children[key]));

  console.log(`Tree has ${topLevelKeys.length} top-level sections.`);

  // --- Write nav-tree.js ---
  const treeJSON = asciiSafeJSON(compactTree);
  const treeFile = path.join(SEARCH_DATA_DIR, 'nav-tree.js');
  fs.writeFileSync(treeFile,
    'window._searchData = window._searchData || {};\n' +
    'window._searchData.navTree = ' + treeJSON + ';\n'
  );
  console.log(`nav-tree.js: ${(treeJSON.length / 1024).toFixed(1)} KB`);

  // --- Build autocomplete data ---
  // Array of { t: title, i: id, b: abbreviated_breadcrumb, p: pageType }
  // Filter out nav-only pages and pages with very short titles
  const autocompleteData = pages
    .filter(p => p.pageType !== 'nav' && p.title && p.title.length > 2)
    .map(p => ({
      t: p.title,
      i: p.id,
      b: p.breadcrumb || '',
      p: p.pageType || 'content'
    }))
    .sort((a, b) => a.t.localeCompare(b.t));

  console.log(`Autocomplete: ${autocompleteData.length} entries.`);

  const acJSON = asciiSafeJSON(autocompleteData);
  const acFile = path.join(SEARCH_DATA_DIR, 'autocomplete.js');
  fs.writeFileSync(acFile,
    'window._searchData = window._searchData || {};\n' +
    'window._searchData.autocomplete = ' + acJSON + ';\n'
  );
  console.log(`autocomplete.js: ${(acJSON.length / 1024).toFixed(1)} KB`);

  // --- Build sibling map using shared groups to save space ---
  // Format: { groups: [[{i,n,p}, ...], ...], map: { pageId: groupIndex } }
  // This avoids duplicating the sibling list for every page in a group
  const sibGroups = [];
  const sibMap = {};

  function buildSiblingMap(node) {
    const childKeys = Object.keys(node.children);
    const childrenWithIds = childKeys
      .map(key => node.children[key])
      .filter(child => child.id);

    // If this node has children that are leaf sections (like Testing, Locations, etc.)
    // group them as siblings
    if (childrenWithIds.length > 1) {
      const groupIdx = sibGroups.length;
      sibGroups.push(childrenWithIds.map(child => ([
        child.id,
        child.name,
        child.pageType || 'content'
      ])));

      for (const child of childrenWithIds) {
        sibMap[child.id] = groupIdx;
      }
    }

    // Recurse
    for (const key of childKeys) {
      buildSiblingMap(node.children[key]);
    }
  }

  buildSiblingMap(tree);

  const sibData = { g: sibGroups, m: sibMap };
  const sibJSON = asciiSafeJSON(sibData);
  const sibFile = path.join(SEARCH_DATA_DIR, 'siblings.js');
  fs.writeFileSync(sibFile,
    'window._searchData = window._searchData || {};\n' +
    'window._searchData.siblings = ' + sibJSON + ';\n'
  );
  console.log(`siblings.js: ${(sibJSON.length / 1024).toFixed(1)} KB (${sibGroups.length} groups)`);

  // --- Also build a parent map: pageId -> parentPageId ---
  // This helps with "up" navigation
  const parentMap = {};

  function buildParentMap(node, parentId) {
    if (node.id && parentId) {
      parentMap[node.id] = parentId;
    }
    const childKeys = Object.keys(node.children);
    for (const key of childKeys) {
      buildParentMap(node.children[key], node.id || parentId);
    }
  }

  buildParentMap(tree, null);

  const parentJSON = asciiSafeJSON(parentMap);
  const parentFile = path.join(SEARCH_DATA_DIR, 'parents.js');
  fs.writeFileSync(parentFile,
    'window._searchData = window._searchData || {};\n' +
    'window._searchData.parents = ' + parentJSON + ';\n'
  );
  console.log(`parents.js: ${(parentJSON.length / 1024).toFixed(1)} KB`);

  console.log('\nNav data build complete!');
}

run();
